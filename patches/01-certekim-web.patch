diff --git a/app/web/client/client.go b/app/web/client/client.go
new file mode 100644
index 0000000..a12de47
--- /dev/null
+++ b/app/web/client/client.go
@@ -0,0 +1,194 @@
+package client
+
+import (
+	"context"
+	"encoding/json"
+	"fmt"
+	"log"
+
+	logCmd "github.com/xtls/xray-core/app/log/command"
+	proxymanCmd "github.com/xtls/xray-core/app/proxyman/command"
+	statsCmd "github.com/xtls/xray-core/app/stats/command"
+	"github.com/xtls/xray-core/common/protocol"
+	"github.com/xtls/xray-core/common/serial"
+	"github.com/xtls/xray-core/infra/conf"
+	"github.com/xtls/xray-core/proxy/vmess"
+	"google.golang.org/grpc"
+)
+
+var Client *ServiceClient
+
+type ServiceClient struct {
+	Address     string
+	Port        uint32
+	statClient  statsCmd.StatsServiceClient
+	proxyClient proxymanCmd.HandlerServiceClient
+	logClient   logCmd.LoggerServiceClient
+}
+
+func NewServiceClient(addr string, port uint32) *ServiceClient {
+	if addr == "" {
+		addr = "127.0.0.1"
+	}
+	if port == 0 {
+		return nil
+	}
+	cmdConn, err := grpc.Dial(fmt.Sprintf("%s:%d", addr, port), grpc.WithInsecure())
+	if err != nil {
+		newError(err)
+		return nil
+	}
+
+	svr := ServiceClient{Address: addr, Port: port,
+		statClient:  statsCmd.NewStatsServiceClient(cmdConn),
+		proxyClient: proxymanCmd.NewHandlerServiceClient(cmdConn),
+		logClient:   logCmd.NewLoggerServiceClient(cmdConn),
+	}
+	return &svr
+}
+
+func (h *ServiceClient) QueryStats(pattern string, reset bool) map[string]int64 {
+	sresp, err := h.statClient.QueryStats(context.Background(), &statsCmd.QueryStatsRequest{
+		Pattern: pattern,
+		Reset_:  reset,
+	})
+
+	result := make(map[string]int64)
+	if err != nil {
+		newError("failed to call grpc command: %v", err)
+	} else {
+		// log.Printf("%v", sresp)
+		for _, stat := range sresp.Stat {
+			result[stat.Name] = stat.Value
+		}
+	}
+
+	return result
+}
+
+func (h *ServiceClient) GetStats(name string, reset bool) (string, int64) {
+	sresp, err := h.statClient.GetStats(context.Background(), &statsCmd.GetStatsRequest{
+		Name:   name,
+		Reset_: reset,
+	})
+
+	if err != nil {
+		newError("%v", err)
+		return "", 0
+	}
+
+	return sresp.Stat.Name, sresp.Stat.Value
+}
+
+func (h *ServiceClient) GetStatsSys() *statsCmd.SysStatsResponse {
+	sresp, err := h.statClient.GetSysStats(context.Background(), &statsCmd.SysStatsRequest{})
+
+	if err != nil {
+		newError("%v", err)
+		return nil
+	}
+
+	return sresp
+}
+
+
+// AddUser ...
+//   Add a user to an inbound on the fly. The effect is not permentnent.
+func (h *ServiceClient) AddUser(inboundTag string, email string, level uint32, uuid string, alterID uint32) {
+	_, err := h.proxyClient.AlterInbound(context.Background(), &proxymanCmd.AlterInboundRequest{
+		Tag: inboundTag,
+		Operation: serial.ToTypedMessage(&proxymanCmd.AddUserOperation{
+			User: &protocol.User{
+				Level: level,
+				Email: email,
+				Account: serial.ToTypedMessage(&vmess.Account{
+					Id:               uuid,
+					AlterId:          alterID,
+					SecuritySettings: &protocol.SecurityConfig{Type: protocol.SecurityType_AUTO},
+				}),
+			},
+		}),
+	})
+
+	if err != nil {
+		newError("%v", err)
+	}
+}
+
+// RemoveUser ...
+//   Remove a user from an Inbound on the fly. The effect is not permentnent.
+func (h *ServiceClient) RemoveUser(inboundTag string, email string) {
+	_, err := h.proxyClient.AlterInbound(context.Background(), &proxymanCmd.AlterInboundRequest{
+		Tag: inboundTag,
+		Operation: serial.ToTypedMessage(&proxymanCmd.RemoveUserOperation{
+			Email: email,
+		}),
+	})
+
+	if err != nil {
+		newError("%v", err)
+	}
+}
+
+// RestartLogger
+// IDK if it will work :D
+func (h *ServiceClient) RestartLogger() {
+	_, err := h.logClient.RestartLogger(context.Background(), &logCmd.RestartLoggerRequest{})
+	if err != nil {
+		newError("%v", err)
+	}
+}
+
+func (h *ServiceClient) AddInbound(in []byte) {
+	var ins *conf.InboundDetourConfig
+	err := json.Unmarshal(in, &ins)
+	if err != nil {
+		log.Printf("failed to build conf: %s", err)
+	}
+	inbound, err := ins.Build()
+	if err != nil {
+		log.Printf("failed to build conf: %s", err)
+	}
+	_, err = h.proxyClient.AddInbound(context.Background(), &proxymanCmd.AddInboundRequest{
+		Inbound: inbound,
+	})
+	if err != nil {
+		newError("%v", err)
+	}
+}
+
+func (h *ServiceClient) AddOutbound(in []byte) {
+	var ins *conf.OutboundDetourConfig
+	err := json.Unmarshal(in, &ins)
+	if err != nil {
+		log.Printf("failed to build conf: %s", err)
+	}
+	outbound, err := ins.Build()
+	if err != nil {
+		log.Printf("failed to build conf: %s", err)
+	}
+	_, err = h.proxyClient.AddOutbound(context.Background(), &proxymanCmd.AddOutboundRequest{
+		Outbound: outbound,
+	})
+	if err != nil {
+		newError("%v", err)
+	}
+}
+
+func (h *ServiceClient) RemoveInbound(tag string) {
+	_, err := h.proxyClient.RemoveInbound(context.Background(), &proxymanCmd.RemoveInboundRequest{
+		Tag: tag,
+	})
+	if err != nil {
+		newError("%v", err)
+	}
+}
+
+func (h *ServiceClient) RemoveOutbound(tag string) {
+	_, err := h.proxyClient.RemoveOutbound(context.Background(), &proxymanCmd.RemoveOutboundRequest{
+		Tag: tag,
+	})
+	if err != nil {
+		newError("%v", err)
+	}
+}
diff --git a/app/web/client/errors.generated.go b/app/web/client/errors.generated.go
new file mode 100644
index 0000000..1ed9507
--- /dev/null
+++ b/app/web/client/errors.generated.go
@@ -0,0 +1,9 @@
+package client
+
+import "github.com/xtls/xray-core/common/errors"
+
+type errPathObjHolder struct{}
+
+func newError(values ...interface{}) *errors.Error {
+	return errors.New(values...).WithPathObj(errPathObjHolder{})
+}
diff --git a/app/web/config/config.pb.go b/app/web/config/config.pb.go
new file mode 100644
index 0000000..b516639
--- /dev/null
+++ b/app/web/config/config.pb.go
@@ -0,0 +1,330 @@
+// Code generated by protoc-gen-go. DO NOT EDIT.
+// versions:
+// 	protoc-gen-go v1.25.0
+// 	protoc        v3.9.2
+// source: config.proto
+
+package config
+
+import (
+	proto "github.com/golang/protobuf/proto"
+	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
+	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
+	reflect "reflect"
+	sync "sync"
+)
+
+const (
+	// Verify that this generated code is sufficiently up-to-date.
+	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
+	// Verify that runtime/protoimpl is sufficiently up-to-date.
+	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
+)
+
+// This is a compile-time assertion that a sufficiently up-to-date version
+// of the legacy proto package is being used.
+const _ = proto.ProtoPackageIsVersion4
+
+// Config is the settings for Web;
+type Config struct {
+	state         protoimpl.MessageState
+	sizeCache     protoimpl.SizeCache
+	unknownFields protoimpl.UnknownFields
+
+	// Tag of the outbound handler that handles Webful API http connections.
+	Tag    string    `protobuf:"bytes,1,opt,name=tag,proto3" json:"tag,omitempty"`
+	Api    *Api      `protobuf:"bytes,2,opt,name=api,proto3" json:"api,omitempty"`
+	Pprof  bool      `protobuf:"varint,3,opt,name=pprof,proto3" json:"pprof,omitempty"`
+	Static []*Static `protobuf:"bytes,4,rep,name=static,proto3" json:"static,omitempty"`
+}
+
+func (x *Config) Reset() {
+	*x = Config{}
+	if protoimpl.UnsafeEnabled {
+		mi := &file_config_proto_msgTypes[0]
+		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
+		ms.StoreMessageInfo(mi)
+	}
+}
+
+func (x *Config) String() string {
+	return protoimpl.X.MessageStringOf(x)
+}
+
+func (*Config) ProtoMessage() {}
+
+func (x *Config) ProtoReflect() protoreflect.Message {
+	mi := &file_config_proto_msgTypes[0]
+	if protoimpl.UnsafeEnabled && x != nil {
+		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
+		if ms.LoadMessageInfo() == nil {
+			ms.StoreMessageInfo(mi)
+		}
+		return ms
+	}
+	return mi.MessageOf(x)
+}
+
+// Deprecated: Use Config.ProtoReflect.Descriptor instead.
+func (*Config) Descriptor() ([]byte, []int) {
+	return file_config_proto_rawDescGZIP(), []int{0}
+}
+
+func (x *Config) GetTag() string {
+	if x != nil {
+		return x.Tag
+	}
+	return ""
+}
+
+func (x *Config) GetApi() *Api {
+	if x != nil {
+		return x.Api
+	}
+	return nil
+}
+
+func (x *Config) GetPprof() bool {
+	if x != nil {
+		return x.Pprof
+	}
+	return false
+}
+
+func (x *Config) GetStatic() []*Static {
+	if x != nil {
+		return x.Static
+	}
+	return nil
+}
+
+type Api struct {
+	state         protoimpl.MessageState
+	sizeCache     protoimpl.SizeCache
+	unknownFields protoimpl.UnknownFields
+
+	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
+	Port    uint32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
+}
+
+func (x *Api) Reset() {
+	*x = Api{}
+	if protoimpl.UnsafeEnabled {
+		mi := &file_config_proto_msgTypes[1]
+		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
+		ms.StoreMessageInfo(mi)
+	}
+}
+
+func (x *Api) String() string {
+	return protoimpl.X.MessageStringOf(x)
+}
+
+func (*Api) ProtoMessage() {}
+
+func (x *Api) ProtoReflect() protoreflect.Message {
+	mi := &file_config_proto_msgTypes[1]
+	if protoimpl.UnsafeEnabled && x != nil {
+		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
+		if ms.LoadMessageInfo() == nil {
+			ms.StoreMessageInfo(mi)
+		}
+		return ms
+	}
+	return mi.MessageOf(x)
+}
+
+// Deprecated: Use Api.ProtoReflect.Descriptor instead.
+func (*Api) Descriptor() ([]byte, []int) {
+	return file_config_proto_rawDescGZIP(), []int{1}
+}
+
+func (x *Api) GetAddress() string {
+	if x != nil {
+		return x.Address
+	}
+	return ""
+}
+
+func (x *Api) GetPort() uint32 {
+	if x != nil {
+		return x.Port
+	}
+	return 0
+}
+
+type Static struct {
+	state         protoimpl.MessageState
+	sizeCache     protoimpl.SizeCache
+	unknownFields protoimpl.UnknownFields
+
+	FilePath string `protobuf:"bytes,1,opt,name=filePath,proto3" json:"filePath,omitempty"`
+	Uri      string `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`
+}
+
+func (x *Static) Reset() {
+	*x = Static{}
+	if protoimpl.UnsafeEnabled {
+		mi := &file_config_proto_msgTypes[2]
+		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
+		ms.StoreMessageInfo(mi)
+	}
+}
+
+func (x *Static) String() string {
+	return protoimpl.X.MessageStringOf(x)
+}
+
+func (*Static) ProtoMessage() {}
+
+func (x *Static) ProtoReflect() protoreflect.Message {
+	mi := &file_config_proto_msgTypes[2]
+	if protoimpl.UnsafeEnabled && x != nil {
+		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
+		if ms.LoadMessageInfo() == nil {
+			ms.StoreMessageInfo(mi)
+		}
+		return ms
+	}
+	return mi.MessageOf(x)
+}
+
+// Deprecated: Use Static.ProtoReflect.Descriptor instead.
+func (*Static) Descriptor() ([]byte, []int) {
+	return file_config_proto_rawDescGZIP(), []int{2}
+}
+
+func (x *Static) GetFilePath() string {
+	if x != nil {
+		return x.FilePath
+	}
+	return ""
+}
+
+func (x *Static) GetUri() string {
+	if x != nil {
+		return x.Uri
+	}
+	return ""
+}
+
+var File_config_proto protoreflect.FileDescriptor
+
+var file_config_proto_rawDesc = []byte{
+	0x0a, 0x0c, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x13,
+	0x78, 0x72, 0x61, 0x79, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x77, 0x65, 0x62, 0x2e, 0x63, 0x6f, 0x6e,
+	0x66, 0x69, 0x67, 0x22, 0x91, 0x01, 0x0a, 0x06, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x10,
+	0x0a, 0x03, 0x74, 0x61, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x74, 0x61, 0x67,
+	0x12, 0x2a, 0x0a, 0x03, 0x61, 0x70, 0x69, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e,
+	0x78, 0x72, 0x61, 0x79, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x77, 0x65, 0x62, 0x2e, 0x63, 0x6f, 0x6e,
+	0x66, 0x69, 0x67, 0x2e, 0x61, 0x70, 0x69, 0x52, 0x03, 0x61, 0x70, 0x69, 0x12, 0x14, 0x0a, 0x05,
+	0x70, 0x70, 0x72, 0x6f, 0x66, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x05, 0x70, 0x70, 0x72,
+	0x6f, 0x66, 0x12, 0x33, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x69, 0x63, 0x18, 0x04, 0x20, 0x03,
+	0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x78, 0x72, 0x61, 0x79, 0x2e, 0x61, 0x70, 0x70, 0x2e, 0x77, 0x65,
+	0x62, 0x2e, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x69, 0x63, 0x52,
+	0x06, 0x73, 0x74, 0x61, 0x74, 0x69, 0x63, 0x22, 0x33, 0x0a, 0x03, 0x61, 0x70, 0x69, 0x12, 0x18,
+	0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
+	0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74,
+	0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x22, 0x36, 0x0a, 0x06,
+	0x73, 0x74, 0x61, 0x74, 0x69, 0x63, 0x12, 0x1a, 0x0a, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x50, 0x61,
+	0x74, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x50, 0x61,
+	0x74, 0x68, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x69, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
+	0x03, 0x75, 0x72, 0x69, 0x42, 0x5b, 0x0a, 0x17, 0x63, 0x6f, 0x6d, 0x2e, 0x78, 0x72, 0x61, 0x79,
+	0x2e, 0x61, 0x70, 0x70, 0x2e, 0x77, 0x65, 0x62, 0x2e, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x50,
+	0x01, 0x5a, 0x28, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x78, 0x74,
+	0x6c, 0x73, 0x2f, 0x78, 0x72, 0x61, 0x79, 0x2d, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x61, 0x70, 0x70,
+	0x2f, 0x77, 0x65, 0x62, 0x2f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0xaa, 0x02, 0x13, 0x58, 0x72,
+	0x61, 0x79, 0x2e, 0x41, 0x70, 0x70, 0x2e, 0x57, 0x65, 0x62, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x69,
+	0x67, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
+}
+
+var (
+	file_config_proto_rawDescOnce sync.Once
+	file_config_proto_rawDescData = file_config_proto_rawDesc
+)
+
+func file_config_proto_rawDescGZIP() []byte {
+	file_config_proto_rawDescOnce.Do(func() {
+		file_config_proto_rawDescData = protoimpl.X.CompressGZIP(file_config_proto_rawDescData)
+	})
+	return file_config_proto_rawDescData
+}
+
+var file_config_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
+var file_config_proto_goTypes = []interface{}{
+	(*Config)(nil), // 0: xray.app.web.config.Config
+	(*Api)(nil),    // 1: xray.app.web.config.api
+	(*Static)(nil), // 2: xray.app.web.config.static
+}
+var file_config_proto_depIdxs = []int32{
+	1, // 0: xray.app.web.config.Config.api:type_name -> xray.app.web.config.api
+	2, // 1: xray.app.web.config.Config.static:type_name -> xray.app.web.config.static
+	2, // [2:2] is the sub-list for method output_type
+	2, // [2:2] is the sub-list for method input_type
+	2, // [2:2] is the sub-list for extension type_name
+	2, // [2:2] is the sub-list for extension extendee
+	0, // [0:2] is the sub-list for field type_name
+}
+
+func init() { file_config_proto_init() }
+func file_config_proto_init() {
+	if File_config_proto != nil {
+		return
+	}
+	if !protoimpl.UnsafeEnabled {
+		file_config_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
+			switch v := v.(*Config); i {
+			case 0:
+				return &v.state
+			case 1:
+				return &v.sizeCache
+			case 2:
+				return &v.unknownFields
+			default:
+				return nil
+			}
+		}
+		file_config_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
+			switch v := v.(*Api); i {
+			case 0:
+				return &v.state
+			case 1:
+				return &v.sizeCache
+			case 2:
+				return &v.unknownFields
+			default:
+				return nil
+			}
+		}
+		file_config_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
+			switch v := v.(*Static); i {
+			case 0:
+				return &v.state
+			case 1:
+				return &v.sizeCache
+			case 2:
+				return &v.unknownFields
+			default:
+				return nil
+			}
+		}
+	}
+	type x struct{}
+	out := protoimpl.TypeBuilder{
+		File: protoimpl.DescBuilder{
+			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
+			RawDescriptor: file_config_proto_rawDesc,
+			NumEnums:      0,
+			NumMessages:   3,
+			NumExtensions: 0,
+			NumServices:   0,
+		},
+		GoTypes:           file_config_proto_goTypes,
+		DependencyIndexes: file_config_proto_depIdxs,
+		MessageInfos:      file_config_proto_msgTypes,
+	}.Build()
+	File_config_proto = out.File
+	file_config_proto_rawDesc = nil
+	file_config_proto_goTypes = nil
+	file_config_proto_depIdxs = nil
+}
diff --git a/app/web/config/config.proto b/app/web/config/config.proto
new file mode 100644
index 0000000..bef72c6
--- /dev/null
+++ b/app/web/config/config.proto
@@ -0,0 +1,27 @@
+syntax = "proto3";
+
+package xray.app.web.config;
+option csharp_namespace = "Xray.App.Web.Config";
+option go_package = "github.com/xtls/xray-core/app/web/config";
+option java_package = "com.xray.app.web.config";
+option java_multiple_files = true;
+
+// Config is the settings for Web;
+message Config {
+    // Tag of the outbound handler that handles Webful API http connections.
+    string tag = 1;
+    api api = 2;
+    bool pprof = 3;
+    repeated static static = 4;
+}
+
+message api {
+    string address = 1;
+    uint32 port = 2;
+}
+
+
+message static {
+    string filePath = 1;
+    string uri = 2;
+}
diff --git a/app/web/errors.generated.go b/app/web/errors.generated.go
new file mode 100644
index 0000000..4225409
--- /dev/null
+++ b/app/web/errors.generated.go
@@ -0,0 +1,9 @@
+package web
+
+import "github.com/xtls/xray-core/common/errors"
+
+type errPathObjHolder struct{}
+
+func newError(values ...interface{}) *errors.Error {
+	return errors.New(values...).WithPathObj(errPathObjHolder{})
+}
diff --git a/app/web/handler/errors.generated.go b/app/web/handler/errors.generated.go
new file mode 100644
index 0000000..711efcf
--- /dev/null
+++ b/app/web/handler/errors.generated.go
@@ -0,0 +1,9 @@
+package handler
+
+import "github.com/xtls/xray-core/common/errors"
+
+type errPathObjHolder struct{}
+
+func newError(values ...interface{}) *errors.Error {
+	return errors.New(values...).WithPathObj(errPathObjHolder{})
+}
diff --git a/app/web/handler/inbound.go b/app/web/handler/inbound.go
new file mode 100644
index 0000000..c3ae768
--- /dev/null
+++ b/app/web/handler/inbound.go
@@ -0,0 +1,30 @@
+package handler
+
+import (
+	"net/http"
+
+	"github.com/julienschmidt/httprouter"
+	"github.com/xtls/xray-core/app/web/client"
+	"github.com/xtls/xray-core/common/log"
+)
+
+//"Content-Type: application/json"
+func AddInboundHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
+	res, err, _ := Convert(r)
+	if err != nil {
+		newError(err)
+		return
+	}
+	client.Client.AddInbound(res)
+}
+
+func RemoveInboundHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
+	data := ps.ByName("tag")
+	log.Record(&log.AccessMessage{
+		From:   "Web",
+		To:     "RemoveInboundHandler",
+		Status: log.AccessAccepted,
+		Detour: data,
+	})
+	client.Client.RemoveInbound(data)
+}
diff --git a/app/web/handler/outbound.go b/app/web/handler/outbound.go
new file mode 100644
index 0000000..8193f48
--- /dev/null
+++ b/app/web/handler/outbound.go
@@ -0,0 +1,29 @@
+package handler
+
+import (
+	"net/http"
+
+	"github.com/julienschmidt/httprouter"
+	"github.com/xtls/xray-core/app/web/client"
+	"github.com/xtls/xray-core/common/log"
+)
+
+func AddOutboundHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
+	res, err, _ := Convert(r)
+	if err != nil {
+		newError(err)
+		return
+	}
+	client.Client.AddOutbound(res)
+}
+
+func RemoveOutboundHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
+	data := ps.ByName("tag")
+	log.Record(&log.AccessMessage{
+		From:   "Web",
+		To:     "RemoveOutboundHandler",
+		Status: log.AccessAccepted,
+		Detour: data,
+	})
+	client.Client.RemoveOutbound(data)
+}
diff --git a/app/web/handler/stats.go b/app/web/handler/stats.go
new file mode 100644
index 0000000..26889d3
--- /dev/null
+++ b/app/web/handler/stats.go
@@ -0,0 +1,60 @@
+package handler
+
+import (
+	"bytes"
+	"encoding/json"
+	"fmt"
+	"net/http"
+	"time"
+
+	"github.com/julienschmidt/httprouter"
+	"github.com/xtls/xray-core/app/web/client"
+)
+
+var boot time.Time
+
+func init() {
+	boot = time.Now()
+}
+
+func GetSysStatsHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
+	response := client.Client.GetStatsSys()
+	if response == nil {
+		fmt.Fprintf(w, "{}")
+	}
+	ret, err := json.Marshal(response)
+	if err != nil {
+		newError(err)
+	} else {
+		fmt.Fprintf(w, "%s\n", string(ret))
+	}
+}
+
+func GetStatsHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
+	data := ps.ByName("name")
+	_, value := client.Client.GetStats(data, false)
+	fmt.Fprintf(w, "%s\n", fmt.Sprintf("%v", value))
+}
+
+func QueryStatsHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
+	data := ps.ByName("pattern")
+	pattern := client.Client.QueryStats(data, false)
+	sub := make(map[string]interface{})
+	for key, val := range pattern {
+		sub[key] = val
+	}
+	var stat []map[string]interface{}
+	stat = append(stat, sub)
+
+	buf := new(bytes.Buffer)
+	enc := json.NewEncoder(buf)
+	enc.SetEscapeHTML(false)
+
+	err := enc.Encode(&stat)
+	if err != nil {
+		newError("failed to convert json")
+		return
+	}
+	//working
+	fmt.Fprintf(w, "%s\n", buf.String())
+}
diff --git a/app/web/handler/utils.go b/app/web/handler/utils.go
new file mode 100644
index 0000000..7fdb5cc
--- /dev/null
+++ b/app/web/handler/utils.go
@@ -0,0 +1,27 @@
+package handler
+
+import (
+	"encoding/json"
+	"log"
+	"net/http"
+)
+
+func Convert(r *http.Request) ([]byte, error, map[string]interface{}) {
+	err := r.ParseForm()
+	if err != nil {
+		log.Println(err)
+		return nil, err, nil
+	}
+	decoder := json.NewDecoder(r.Body)
+	var params map[string]interface{}
+	if err := decoder.Decode(&params); err != nil {
+		log.Println(err)
+		return nil, err, nil
+	}
+	res, err := json.Marshal(params)
+	if err != nil {
+		log.Println(err)
+		return nil, err, nil
+	}
+	return res, nil, params
+}
diff --git a/app/web/outbound.go b/app/web/outbound.go
new file mode 100644
index 0000000..37ebd12
--- /dev/null
+++ b/app/web/outbound.go
@@ -0,0 +1,109 @@
+package web
+
+import (
+	"context"
+	"sync"
+
+	"github.com/xtls/xray-core/common"
+	"github.com/xtls/xray-core/common/net"
+	"github.com/xtls/xray-core/common/net/cnc"
+	"github.com/xtls/xray-core/common/signal/done"
+	"github.com/xtls/xray-core/transport"
+)
+
+// OutboundListener is a net.Listener for listening http connections.
+type OutboundListener struct {
+	buffer chan net.Conn
+	done   *done.Instance
+}
+
+func (l *OutboundListener) add(conn net.Conn) {
+	select {
+	case l.buffer <- conn:
+	case <-l.done.Wait():
+		conn.Close()
+	default:
+		conn.Close()
+	}
+}
+
+// Accept implements net.Listener.
+func (l *OutboundListener) Accept() (net.Conn, error) {
+	select {
+	case <-l.done.Wait():
+		return nil, newError("listen closed")
+	case c := <-l.buffer:
+		return c, nil
+	}
+}
+
+// Close implement net.Listener.
+func (l *OutboundListener) Close() error {
+	common.Must(l.done.Close())
+L:
+	for {
+		select {
+		case c := <-l.buffer:
+			c.Close()
+		default:
+			break L
+		}
+	}
+	return nil
+}
+
+// Addr implements net.Listener.
+func (l *OutboundListener) Addr() net.Addr {
+	return &net.TCPAddr{
+		IP:   net.IP{0, 0, 0, 0},
+		Port: 0,
+	}
+}
+
+// Outbound is a outbound.Handler that handles http connections.
+type Outbound struct {
+	tag      string
+	listener *OutboundListener
+	access   sync.RWMutex
+	closed   bool
+}
+
+// Dispatch implements outbound.Handler.
+func (co *Outbound) Dispatch(ctx context.Context, link *transport.Link) {
+	co.access.RLock()
+
+	if co.closed {
+		common.Interrupt(link.Reader)
+		common.Interrupt(link.Writer)
+		co.access.RUnlock()
+		return
+	}
+
+	closeSignal := done.New()
+	c := cnc.NewConnection(cnc.ConnectionInputMulti(link.Writer), cnc.ConnectionOutputMulti(link.Reader), cnc.ConnectionOnClose(closeSignal))
+	co.listener.add(c)
+	co.access.RUnlock()
+	<-closeSignal.Wait()
+}
+
+// Tag implements outbound.Handler.
+func (co *Outbound) Tag() string {
+	return co.tag
+}
+
+// Start implements common.Runnable.
+func (co *Outbound) Start() error {
+	co.access.Lock()
+	co.closed = false
+	co.access.Unlock()
+	return nil
+}
+
+// Close implements common.Closable.
+func (co *Outbound) Close() error {
+	co.access.Lock()
+	defer co.access.Unlock()
+
+	co.closed = true
+	return co.listener.Close()
+}
diff --git a/app/web/router.go b/app/web/router.go
new file mode 100644
index 0000000..e60ef0e
--- /dev/null
+++ b/app/web/router.go
@@ -0,0 +1,53 @@
+package web
+
+import (
+	"fmt"
+	"net/http"
+
+	"github.com/julienschmidt/httprouter"
+	"github.com/xtls/xray-core/app/web/client"
+	"github.com/xtls/xray-core/app/web/handler"
+	"github.com/xtls/xray-core/core"
+)
+
+func Default(config *WebHandler) *httprouter.Router {
+	router := httprouter.New()
+
+	if config.api.port != 0 {
+		client.Client = client.NewServiceClient(config.api.address, config.api.port)
+		router.GET("/api/v1/statssys", handler.GetSysStatsHandler)
+		router.GET("/api/v1/statsquery", handler.QueryStatsHandler)
+		router.GET("/api/v1/statsquery/:pattern", handler.QueryStatsHandler)
+		router.GET("/api/v1/stats", handler.GetStatsHandler)
+		router.GET("/api/v1/stats/:name", handler.GetStatsHandler)
+		router.DELETE("/api/v1/inbounds/:tag", handler.RemoveInboundHandler)
+		router.POST("/api/v1/inbounds", handler.AddInboundHandler)
+		router.DELETE("/api/v1/outbounds/:tag", handler.RemoveOutboundHandler)
+		router.POST("/api/v1/outbounds", handler.AddOutboundHandler)
+	}
+
+	if config.pprof {
+		router.Handler(http.MethodGet, "/debug/pprof/*item", http.DefaultServeMux)
+		router.Handler(http.MethodGet, "/debug/vars", http.DefaultServeMux)
+	}
+
+	if config.static != nil {
+		for _, s := range config.static {
+			if s.uri == "/" {
+				router.NotFound = http.FileServer(http.Dir(s.filePath))
+			} else {
+				router.ServeFiles(s.uri+"/*filepath", http.Dir(s.filePath))
+			}
+		}
+	} else {
+		router.GET("/", DefaultHandler)
+	}
+
+	return router
+}
+
+func DefaultHandler(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
+	for _, s := range core.VersionStatement() {
+		fmt.Fprintf(w, "%s\n", s)
+	}
+}
diff --git a/app/web/web.go b/app/web/web.go
new file mode 100644
index 0000000..78e5b98
--- /dev/null
+++ b/app/web/web.go
@@ -0,0 +1,105 @@
+package web
+
+import (
+	"context"
+	"expvar"
+	"net/http"
+	_ "net/http/pprof"
+	"runtime"
+	"time"
+
+	"github.com/xtls/xray-core/app/web/config"
+	"github.com/xtls/xray-core/common"
+	"github.com/xtls/xray-core/common/net"
+	"github.com/xtls/xray-core/common/signal/done"
+	"github.com/xtls/xray-core/core"
+	"github.com/xtls/xray-core/features/outbound"
+)
+
+type WebHandler struct {
+	ohm    outbound.Manager
+	tag    string
+	api    Api
+	pprof  bool
+	static []Static
+}
+
+type Api struct {
+	address string
+	port    uint32
+}
+
+type Static struct {
+	filePath string
+	uri      string
+}
+
+// New
+func NewWebHandler(ctx context.Context, config *config.Config) (*WebHandler, error) {
+	c := &WebHandler{
+		tag: config.Tag,
+		api: Api{
+			address: config.Api.Address,
+			port:    config.Api.Port,
+		},
+		pprof: config.Pprof,
+	}
+
+	if config.Pprof {
+		now := time.Now()
+		expvar.Publish("Uptime", expvar.Func(func() interface{} {
+			return time.Since(now) / time.Second
+		}))
+		expvar.Publish("NumGoroutine", expvar.Func(func() interface{} {
+			return runtime.NumGoroutine()
+		}))
+	}
+
+	for _, s := range config.Static {
+		c.static = append(c.static, Static{
+			filePath: s.FilePath,
+			uri:      s.Uri,
+		})
+	}
+
+	common.Must(core.RequireFeatures(ctx, func(om outbound.Manager) {
+		c.ohm = om
+	}))
+	return c, nil
+}
+
+func (r *WebHandler) Type() interface{} {
+	return (*WebHandler)(nil)
+}
+
+func (r *WebHandler) Start() error {
+	listener := &OutboundListener{
+		buffer: make(chan net.Conn, 4),
+		done:   done.New(),
+	}
+
+	go func() {
+		if err := http.Serve(listener, Default(r)); err != nil {
+			newError("failed to start Web server").Base(err).AtError().WriteToLog()
+		}
+	}()
+
+	if err := r.ohm.RemoveHandler(context.Background(), r.tag); err != nil {
+		newError("failed to remove existing handler").WriteToLog()
+	}
+
+	return r.ohm.AddHandler(context.Background(), &Outbound{
+		tag:      r.tag,
+		listener: listener,
+	})
+}
+
+func (r *WebHandler) Close() error {
+	return nil
+}
+
+func init() {
+	common.Must(common.RegisterConfig((*config.Config)(nil), func(ctx context.Context, cfg interface{}) (interface{}, error) {
+		return NewWebHandler(ctx, cfg.(*config.Config))
+	}))
+}
diff --git a/go.mod b/go.mod
index ab896fc..da8209d 100644
--- a/go.mod
+++ b/go.mod
@@ -3,11 +3,12 @@ module github.com/xtls/xray-core
 go 1.17
 
 require (
-	github.com/ghodss/yaml v1.0.1-0.20190212211648-25d852aebe32
+	github.com/ghodss/yaml v1.0.0
 	github.com/golang/mock v1.6.0
 	github.com/golang/protobuf v1.5.2
 	github.com/google/go-cmp v0.5.7
 	github.com/gorilla/websocket v1.4.2
+	github.com/julienschmidt/httprouter v1.3.0
 	github.com/lucas-clemente/quic-go v0.25.0
 	github.com/miekg/dns v1.1.45
 	github.com/pelletier/go-toml v1.9.4
@@ -17,11 +18,11 @@ require (
 	github.com/stretchr/testify v1.7.0
 	github.com/v2fly/ss-bloomring v0.0.0-20210312155135-28617310f63e
 	github.com/xtls/go v0.0.0-20210920065950-d4af136d3672
-	go.starlark.net v0.0.0-20211203141949-70c0e40ae128
-	golang.org/x/crypto v0.0.0-20220128200615-198e4374d7ed
+	go.starlark.net v0.0.0-20220203230714-bb14e151c28f
+	golang.org/x/crypto v0.0.0-20220131195533-30dcbda58838
 	golang.org/x/net v0.0.0-20220127200216-cd36cc0744dd
 	golang.org/x/sync v0.0.0-20210220032951-036812b2e83c
-	golang.org/x/sys v0.0.0-20220128215802-99c3d69c2c27
+	golang.org/x/sys v0.0.0-20220204135822-1c1b9b1eba6a
 	google.golang.org/grpc v1.44.0
 	google.golang.org/protobuf v1.27.1
 	h12.io/socks v1.0.3
@@ -40,12 +41,11 @@ require (
 	github.com/onsi/ginkgo v1.16.5 // indirect
 	github.com/pmezard/go-difflib v1.0.0 // indirect
 	github.com/riobard/go-bloom v0.0.0-20200614022211-cdc8013cb5b3 // indirect
-	github.com/stretchr/objx v0.3.0 // indirect
 	golang.org/x/mod v0.5.1 // indirect
 	golang.org/x/text v0.3.7 // indirect
 	golang.org/x/tools v0.1.9 // indirect
 	golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1 // indirect
-	google.golang.org/genproto v0.0.0-20220126215142-9970aeb2e350 // indirect
+	google.golang.org/genproto v0.0.0-20220204002441-d6cc3cc0770e // indirect
 	gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 // indirect
 	gopkg.in/yaml.v2 v2.4.0 // indirect
 	gopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b // indirect
diff --git a/go.sum b/go.sum
index 1ba2f37..d9a9a98 100644
--- a/go.sum
+++ b/go.sum
@@ -35,8 +35,6 @@ github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSs
 github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
 github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
 github.com/dgryski/go-metro v0.0.0-20200812162917-85c65e2d0165/go.mod h1:c9O8+fpSOX1DM8cPNSkX/qsBWdkD4yd2dpciOWQjpBw=
-github.com/dgryski/go-metro v0.0.0-20211015221634-2661b20a2446 h1:QnWGyQI3H080vbC9E4jlr6scOYEnALtvV/69oATYzOo=
-github.com/dgryski/go-metro v0.0.0-20211015221634-2661b20a2446/go.mod h1:c9O8+fpSOX1DM8cPNSkX/qsBWdkD4yd2dpciOWQjpBw=
 github.com/dgryski/go-metro v0.0.0-20211217172704-adc40b04c140 h1:y7y0Oa6UawqTFPCDw9JG6pdKt4F9pAhHv0B7FMGaGD0=
 github.com/dgryski/go-metro v0.0.0-20211217172704-adc40b04c140/go.mod h1:c9O8+fpSOX1DM8cPNSkX/qsBWdkD4yd2dpciOWQjpBw=
 github.com/dustin/go-humanize v1.0.0/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=
@@ -53,9 +51,8 @@ github.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMo
 github.com/fsnotify/fsnotify v1.4.9/go.mod h1:znqG4EE+3YCdAaPaxE2ZRY/06pZUdp0tY4IgpuI1SZQ=
 github.com/fsnotify/fsnotify v1.5.1 h1:mZcQUHVQUQWoPXXtuf9yuEXKudkV2sx1E06UadKWpgI=
 github.com/fsnotify/fsnotify v1.5.1/go.mod h1:T3375wBYaZdLLcVNkcVbzGHY7f1l/uK5T5Ai1i3InKU=
+github.com/ghodss/yaml v1.0.0 h1:wQHKEahhL6wmXdzwWG11gIVCkOv05bNOh+Rxn0yngAk=
 github.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=
-github.com/ghodss/yaml v1.0.1-0.20190212211648-25d852aebe32 h1:Mn26/9ZMNWSw9C9ERFA1PUxfmGpolnw2v0bKOREu5ew=
-github.com/ghodss/yaml v1.0.1-0.20190212211648-25d852aebe32/go.mod h1:GIjDIg/heH5DOkXY3YJ/wNhfHsQHoXGjl8G8amsYQ1I=
 github.com/gliderlabs/ssh v0.1.1/go.mod h1:U7qILu1NlMHj9FlMhZLlkCdDnU1DBEAqr0aevW3Awn0=
 github.com/go-errors/errors v1.0.1/go.mod h1:f4zRHt4oKfwPJE5k8C9vpYG+aDHdBFUsgrm6/TyX73Q=
 github.com/go-task/slim-sprig v0.0.0-20210107165309-348f09dbbbc0 h1:p104kn46Q8WdvHunIJ9dAyjPVtrBPhSr3KT2yUst43I=
@@ -112,6 +109,8 @@ github.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpO
 github.com/jellevandenhooff/dkim v0.0.0-20150330215556-f50fe3d243e1/go.mod h1:E0B/fFc00Y+Rasa88328GlI/XbtyysCtTHZS8h7IrBU=
 github.com/json-iterator/go v1.1.6/go.mod h1:+SdeFBvtyEkXs7REEP0seUULqWtbJapLOCVDaaPEHmU=
 github.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=
+github.com/julienschmidt/httprouter v1.3.0 h1:U0609e9tgbseu3rBINet9P48AI/D3oJs4dN7jwJOQ1U=
+github.com/julienschmidt/httprouter v1.3.0/go.mod h1:JR6WtHb+2LUe8TCKY3cZOxFyyO8IZAc4RVcycCCAKdM=
 github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
 github.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=
 github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
@@ -202,12 +201,8 @@ github.com/shurcooL/webdavfs v0.0.0-20170829043945-18c3829fa133/go.mod h1:hKmq5k
 github.com/sourcegraph/annotate v0.0.0-20160123013949-f4cad6c6324d/go.mod h1:UdhH50NIW0fCiwBSr0co2m7BnFLdv4fQTgdqdJTHFeE=
 github.com/sourcegraph/syntaxhighlight v0.0.0-20170531221838-bd320f5d308e/go.mod h1:HuIsMU8RRBOtsCgI77wP899iHVBQpCmg4ErYMZB+2IA=
 github.com/spaolacci/murmur3 v0.0.0-20180118202830-f09979ecbc72/go.mod h1:JwIasOWyU6f++ZhiEuf87xNszmSA2myDM2Kzu9HwQUA=
-github.com/stretchr/objx v0.1.0 h1:4G4v2dO3VZwixGIRoQ5Lfboy6nUhCyYzaqnIAPPhYs4=
 github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
-github.com/stretchr/objx v0.3.0 h1:NGXK3lHquSN08v5vWalVI/L8XU9hdzE/G6xsrze47As=
-github.com/stretchr/objx v0.3.0/go.mod h1:qt09Ya8vawLte6SNmTgCsAVtYtaKzEcn8ATUoHMkEqE=
 github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
-github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
 github.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=
 github.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
 github.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY=
@@ -224,8 +219,8 @@ github.com/yuin/goldmark v1.3.5/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1
 github.com/yuin/goldmark v1.4.1/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=
 go.opencensus.io v0.18.0/go.mod h1:vKdFvxhtzZ9onBp9VKHK8z/sRpBMnKAsufL7wlDrCOA=
 go.opentelemetry.io/proto/otlp v0.7.0/go.mod h1:PqfVotwruBrMGOCsRd/89rSnXhoiJIqeYNgFYFoEGnI=
-go.starlark.net v0.0.0-20211203141949-70c0e40ae128 h1:bxH+EXOo87zEOwKDdZ8Tevgi6irRbqheRm/fr293c58=
-go.starlark.net v0.0.0-20211203141949-70c0e40ae128/go.mod h1:t3mmBBPzAVvK0L0n1drDmrQsJ8FoIx4INCqVMTr/Zo0=
+go.starlark.net v0.0.0-20220203230714-bb14e151c28f h1:aW4TkS39/naJa9wPSbIXtZUQOlvuUh8gxCsLRrJoByU=
+go.starlark.net v0.0.0-20220203230714-bb14e151c28f/go.mod h1:t3mmBBPzAVvK0L0n1drDmrQsJ8FoIx4INCqVMTr/Zo0=
 go4.org v0.0.0-20180809161055-417644f6feb5/go.mod h1:MkTOUMDaeVYJUOUsaDXIhWPZYa1yOyC1qaOBpL57BhE=
 golang.org/x/build v0.0.0-20190111050920-041ab4dc3f9d/go.mod h1:OWs+y06UdEOHN4y+MfF/py+xQ/tYqIWW03b70/CG9Rw=
 golang.org/x/crypto v0.0.0-20181030102418-4d3f4d9ffa16/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=
@@ -235,10 +230,8 @@ golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8U
 golang.org/x/crypto v0.0.0-20200221231518-2aa609cf4a9d/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
 golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
 golang.org/x/crypto v0.0.0-20210817164053-32db794688a5/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
-golang.org/x/crypto v0.0.0-20211209193657-4570a0811e8b h1:QAqMVf3pSa6eeTsuklijukjXBlj7Es2QQplab+/RbQ4=
-golang.org/x/crypto v0.0.0-20211209193657-4570a0811e8b/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
-golang.org/x/crypto v0.0.0-20220128200615-198e4374d7ed h1:YoWVYYAfvQ4ddHv3OKmIvX7NCAhFGTj62VP2l2kfBbA=
-golang.org/x/crypto v0.0.0-20220128200615-198e4374d7ed/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
+golang.org/x/crypto v0.0.0-20220131195533-30dcbda58838 h1:71vQrMauZZhcTVK6KdYM+rklehEEwb3E+ZhaE5jrPrE=
+golang.org/x/crypto v0.0.0-20220131195533-30dcbda58838/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
 golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
 golang.org/x/lint v0.0.0-20180702182130-06c8688daad7/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
 golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
@@ -268,9 +261,9 @@ golang.org/x/net v0.0.0-20210405180319-a5a99cb37ef4/go.mod h1:p54w0d4576C0XHj96b
 golang.org/x/net v0.0.0-20210428140749-89ef3d95e781/go.mod h1:OJAsFXCWl8Ukc7SiCT/9KSuxbyM7479/AVlXFRxuMCk=
 golang.org/x/net v0.0.0-20210726213435-c6fcb2dbf985/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
 golang.org/x/net v0.0.0-20211015210444-4f30a5c0130f/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
+golang.org/x/net v0.0.0-20211015210444-4f30a5c0130f/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
+golang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
 golang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
-golang.org/x/net v0.0.0-20211209124913-491a49abca63 h1:iocB37TsdFuN6IBRZ+ry36wrkoV51/tl5vOWqkcPGvY=
-golang.org/x/net v0.0.0-20211209124913-491a49abca63/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
 golang.org/x/net v0.0.0-20220127200216-cd36cc0744dd h1:O7DYs+zxREGLKzKoMQrtrEacpb0ZVXA5rIwylE2Xchk=
 golang.org/x/net v0.0.0-20220127200216-cd36cc0744dd/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=
 golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
@@ -309,11 +302,11 @@ golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBc
 golang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.0.0-20210908233432-aa78b53d3365/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.0.0-20211019181941-9d821ace8654/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
-golang.org/x/sys v0.0.0-20211214234402-4825e8c3871d h1:1oIt9o40TWWI9FUaveVpUvBe13FNqBNVXy3ue2fcfkw=
-golang.org/x/sys v0.0.0-20211214234402-4825e8c3871d/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
-golang.org/x/sys v0.0.0-20220128215802-99c3d69c2c27 h1:XDXtA5hveEEV8JB2l7nhMTp3t3cHp9ZpwcdjqyEWLlo=
-golang.org/x/sys v0.0.0-20220128215802-99c3d69c2c27/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.0.0-20211216021012-1d35b9e2eb4e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.0.0-20220204135822-1c1b9b1eba6a h1:ppl5mZgokTT8uPkmYOyEUmPTr3ypaKkg5eFOGrAmxxE=
+golang.org/x/sys v0.0.0-20220204135822-1c1b9b1eba6a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
+golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
 golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
 golang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
 golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=
@@ -336,8 +329,6 @@ golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtn
 golang.org/x/tools v0.0.0-20201224043029-2b0845dc783e/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
 golang.org/x/tools v0.1.1/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=
 golang.org/x/tools v0.1.6-0.20210726203631-07bc1bf47fb2/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=
-golang.org/x/tools v0.1.8 h1:P1HhGGuLW4aAclzjtmJdf0mJOjVUZUzOTqkAkWL+l6w=
-golang.org/x/tools v0.1.8/go.mod h1:nABZi5QlRsZVlzPpHl034qft6wpY4eDcsTt5AaioBiU=
 golang.org/x/tools v0.1.9 h1:j9KsMiaP1c3B0OTQGth0/k+miLGTgLsAFUCrF2vLcF8=
 golang.org/x/tools v0.1.9/go.mod h1:nABZi5QlRsZVlzPpHl034qft6wpY4eDcsTt5AaioBiU=
 golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
@@ -360,10 +351,8 @@ google.golang.org/genproto v0.0.0-20190306203927-b5d61aea6440/go.mod h1:VzzqZJRn
 google.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
 google.golang.org/genproto v0.0.0-20200513103714-09dca8ec2884/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
 google.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=
-google.golang.org/genproto v0.0.0-20211208223120-3a66f561d7aa h1:I0YcKz0I7OAhddo7ya8kMnvprhcWM045PmkBdMO9zN0=
-google.golang.org/genproto v0.0.0-20211208223120-3a66f561d7aa/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=
-google.golang.org/genproto v0.0.0-20220126215142-9970aeb2e350 h1:YxHp5zqIcAShDEvRr5/0rVESVS+njYF68PSdazrNLJo=
-google.golang.org/genproto v0.0.0-20220126215142-9970aeb2e350/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=
+google.golang.org/genproto v0.0.0-20220204002441-d6cc3cc0770e h1:hXl9hnyOkeznztYpYxVPAVZfPzcbO6Q0C+nLXodza8k=
+google.golang.org/genproto v0.0.0-20220204002441-d6cc3cc0770e/go.mod h1:5CzLGKJ67TSI2B9POpiiyGha0AjJvZIUgRMt1dSmuhc=
 google.golang.org/grpc v1.14.0/go.mod h1:yo6s7OP7yaDglbqo1J04qKzAhqBH6lvTonzMVmEdcZw=
 google.golang.org/grpc v1.16.0/go.mod h1:0JHn/cJsOMiMfNA9+DeHDlAU7KAAB5GDlYFpa9MZMio=
 google.golang.org/grpc v1.17.0/go.mod h1:6QZJwpn2B+Zp71q/5VxRsJ6NXXVCE5NRUHRo+f3cWCs=
diff --git a/infra/conf/web.go b/infra/conf/web.go
new file mode 100644
index 0000000..8e19b57
--- /dev/null
+++ b/infra/conf/web.go
@@ -0,0 +1,66 @@
+package conf
+
+import (
+	"github.com/xtls/xray-core/app/web/config"
+)
+
+type WebConfig struct {
+	Tag    string          `json:"tag"`
+	Api    *ApiConfig      `json:"api"`
+	Pprof  bool            `json:"pprof"`
+	Static []*StaticConfig `json:"static"`
+}
+
+type ApiConfig struct {
+	Address string `json:"address"`
+	Port    uint32 `json:"port"`
+}
+
+type StaticConfig struct {
+	FilePath string `json:"filePath"`
+	Uri      string `json:"uri"`
+}
+
+func (c *StaticConfig) Build() (*config.Static, error) {
+	if c.FilePath == "" {
+		return nil, newError("could not serve nil filepath")
+	}
+
+	if c.Uri == "" {
+		return nil, newError("could not use void as uri")
+	}
+
+	return &config.Static{
+		FilePath: c.FilePath,
+		Uri:      c.Uri,
+	}, nil
+}
+
+func (c *WebConfig) Build() (*config.Config, error) {
+	if c.Tag == "" {
+		return nil, newError("Web tag can't be empty.")
+	}
+
+	if c.Api == nil {
+		c.Api = &ApiConfig{}
+	}
+
+	conf := &config.Config{
+		Tag: c.Tag,
+		Api: &config.Api{
+			Address: c.Api.Address,
+			Port:    c.Api.Port,
+		},
+		Pprof: c.Pprof,
+	}
+
+	for _, static := range c.Static {
+		s, err := static.Build()
+		if err != nil {
+			return nil, newError("failed to build http file server")
+		}
+		conf.Static = append(conf.Static, s)
+	}
+
+	return conf, nil
+}
diff --git a/infra/conf/xray.go b/infra/conf/xray.go
index 6a00707..32586dd 100644
--- a/infra/conf/xray.go
+++ b/infra/conf/xray.go
@@ -411,6 +411,7 @@ type Config struct {
 	Transport       *TransportConfig       `json:"transport"`
 	Policy          *PolicyConfig          `json:"policy"`
 	API             *APIConfig             `json:"api"`
+	Web             *WebConfig             `json:"web"`
 	Stats           *StatsConfig           `json:"stats"`
 	Reverse         *ReverseConfig         `json:"reverse"`
 	FakeDNS         *FakeDNSConfig         `json:"fakeDns"`
@@ -461,6 +462,9 @@ func (c *Config) Override(o *Config, fn string) {
 	if o.API != nil {
 		c.API = o.API
 	}
+	if o.Web != nil {
+		c.Web = o.Web
+	}
 	if o.Stats != nil {
 		c.Stats = o.Stats
 	}
@@ -567,6 +571,14 @@ func (c *Config) Build() (*core.Config, error) {
 		config.App = append(config.App, serial.ToTypedMessage(apiConf))
 	}
 
+	if c.Web != nil {
+		WebConf, err := c.Web.Build()
+		if err != nil {
+			return nil, err
+		}
+		config.App = append(config.App, serial.ToTypedMessage(WebConf))
+	}
+
 	if c.Stats != nil {
 		statsConf, err := c.Stats.Build()
 		if err != nil {
diff --git a/main/distro/all/all.go b/main/distro/all/all.go
index cc1dcac..4ae23d6 100644
--- a/main/distro/all/all.go
+++ b/main/distro/all/all.go
@@ -25,6 +25,7 @@ import (
 	_ "github.com/xtls/xray-core/app/reverse"
 	_ "github.com/xtls/xray-core/app/router"
 	_ "github.com/xtls/xray-core/app/stats"
+	_ "github.com/xtls/xray-core/app/web"
 
 	// Fix dependency cycle caused by core import in internet package
 	_ "github.com/xtls/xray-core/transport/internet/tagged/taggedimpl"
